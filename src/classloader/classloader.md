##### 类加载器的代理模式

- 什么是代理模式

- 双亲委派模型
![](https://ws3.sinaimg.cn/large/006tKfTcly1ftghofmzecj30t80n275g.jpg)
>双亲委派模型的继承关系我就不讲了。这里主要是过程

- 双亲委派模型为什么能保证Java核心库的类型安全
> 对象相等有两个条件，第一是类名相同，第二是相同加载器加载，所以当很多类引用`Java`核心类库时，代理模式让`Java`核心类库<->引导类加载器.保证 Java 核心库的类型安全.试想如果每个类都由不同的加载器加载，很有可能形成多个版本的类

- 双亲委派模型在实践中的问题：不能封装自己想要的库
> 我想将一部分`Java`核心类库封装成一个我自己想要的`Library`，比如`Tomcat`，问题在于：你自己写的类是由`AppClassLoader`加载，就达不到自己想要的效果。其实双亲委派模型是达不到上诉效果的。

- 线程上下文加载器（一个不太优雅的设计）

- 热更新的实现
> 当用户选择更新是，将需要更新的`.class`文件发送给客户端，客户端点击更新会运行自定义的类加载器

- Tomcat类加载器的实现原理及举例
![](https://ws2.sinaimg.cn/large/006tKfTcly1ftgiwz56zgj30re0tswh5.jpg)
> 解释如下：`App classLoader`的下层的类加载器都是`Tomcat`自定义的加载器，所以其可以自定义下层部分的模型逻辑，奇怪的是下层模型与双亲委派模型的逻辑相反即当`Catalina ClassLoader`接受到请求会先执行`findClass`，没有才传递给`Common ClassLoader`。

- Tomcat下层模型逻辑原因：解决了"不能封装自己想要的库"的问题
> 为了实现之前所提到的功能，`TomCat`想做成一个类库，双亲委派模型是实现不了的。下层模型便解决了这个问题，当底层收到类加载请求。

- Tomcat为什么可以开多个
> 原因在于其定义的类加载器可以创建不同的实例